#!/bin/bash
# reverse ssh proxy
# example:
#   serve a proxy on host to remote: rbsprox -r <remote> 
#   use proxy to host from remote to anyhost: rbsprox <anyhost>  
#
# Author: joknarf

usage() {
  printf '%s' 'usage: 
  server: rbsprox -r <remote> [-R <remotename>] [-p proxy] [-P proxyname] [-f fifo] [-c config] [-a]
  client: rbsprox <target>

  -r remote     : ip/host to serve shell/command (optionally prefixed with user@)
  -R remotename : ssh Host alias to connect to remote (remote)
  -p proxy      : proxy to connect to remote (optionally prefixed with user@) (localhost)
  -P proxyname  : ssh Host alias to connect to proxy (proxy)
  -c config     : config file to load (~/.rbs.conf)
  -f fifo       : fixed fifo basename to use, [A-Za-z0-9] characters only (default random)
  -a            : always serve (relaunch on disconnect)

in your ~/.ssh/config add Include ~/.ssh/rbs (or ssh will be run with -F ~/.ssh/rbs)
'
  exit 0
}

rbs_pre() {
  logo=$(base64 -d <<'EOF'
G1szODs1OzE4NG0gG1szOW0bWzM4OzU7MjE0bSAbWzM5bRtbMzg7NTsyMTRtIBtbMzltG1szODs1
OzIwOG0gG1szOW0bWzM4OzU7MjA4bSAbWzM5bRtbMzg7NTsyMDNtIBtbMzltG1szODs1OzIwM20g
G1szOW0bWzM4OzU7MTk4bSAbWzM5bRtbMzg7NTsxOThtIBtbMzltG1szODs1OzE5OW1fG1szOW0b
WzM4OzU7MTk5bV8bWzM5bRtbMzg7NTsxNjRtIBtbMzltG1szODs1OzE2NG0gG1szOW0bWzM4OzU7
MTY0bSAbWzM5bRtbMzg7NTsxMjltIBtbMzltG1szODs1OzEyOW0gG1szOW0bWzM4OzU7OTNtIBtb
MzltG1szODs1OzkzbSAbWzM5bRtbMzg7NTs2M20gG1szOW0bWzM4OzU7NjNtG1szOW0KG1szODs1
OzIwOG0gG1szOW0bWzM4OzU7MjA4bSAbWzM5bRtbMzg7NTsyMDNtIBtbMzltG1szODs1OzIwM21f
G1szOW0bWzM4OzU7MTk4bV8bWzM5bRtbMzg7NTsxOThtXxtbMzltG1szODs1OzE5OW1fG1szOW0b
WzM4OzU7MTk5bV8bWzM5bRtbMzg7NTsxNjRtLxtbMzltG1szODs1OzE2NG0gG1szOW0bWzM4OzU7
MTY0bS8bWzM5bRtbMzg7NTsxMjltXxtbMzltG1szODs1OzEyOW0gG1szOW0bWzM4OzU7OTNtIBtb
MzltG1szODs1OzkzbV8bWzM5bRtbMzg7NTs2M21fG1szOW0bWzM4OzU7NjNtXxtbMzltG1szODs1
OzMzbV8bWzM5bRtbMzg7NTszM21fG1szOW0bWzM4OzU7MzltG1szOW0KG1szODs1OzIwM20gG1sz
OW0bWzM4OzU7MTk4bSAbWzM5bRtbMzg7NTsxOThtLxtbMzltG1szODs1OzE5OW0gG1szOW0bWzM4
OzU7MTk5bV8bWzM5bRtbMzg7NTsxNjRtXxtbMzltG1szODs1OzE2NG1fG1szOW0bWzM4OzU7MTY0
bS8bWzM5bRtbMzg7NTsxMjltIBtbMzltG1szODs1OzEyOW1fG1szOW0bWzM4OzU7OTNtXxtbMzlt
G1szODs1OzkzbSAbWzM5bRtbMzg7NTs2M21cG1szOW0bWzM4OzU7NjNtLxtbMzltG1szODs1OzMz
bSAbWzM5bRtbMzg7NTszM21fG1szOW0bWzM4OzU7MzltXxtbMzltG1szODs1OzM5bV8bWzM5bRtb
Mzg7NTs0NG0vG1szOW0bWzM4OzU7NDRtG1szOW0KG1szODs1OzE5OW0gG1szOW0bWzM4OzU7MTk5
bS8bWzM5bRtbMzg7NTsxNjRtIBtbMzltG1szODs1OzE2NG0vG1szOW0bWzM4OzU7MTY0bSAbWzM5
bRtbMzg7NTsxMjltIBtbMzltG1szODs1OzEyOW0vG1szOW0bWzM4OzU7OTNtIBtbMzltG1szODs1
OzkzbS8bWzM5bRtbMzg7NTs2M21fG1szOW0bWzM4OzU7NjNtLxtbMzltG1szODs1OzMzbSAbWzM5
bRtbMzg7NTszM20oG1szOW0bWzM4OzU7MzltXxtbMzltG1szODs1OzM5bV8bWzM5bRtbMzg7NTs0
NG0gG1szOW0bWzM4OzU7NDRtIBtbMzltG1szODs1OzQ5bSkbWzM5bRtbMzg7NTs0OW0gG1szOW0b
WzM4OzU7NDhtG1szOW0KG1szODs1OzE2NG0vG1szOW0bWzM4OzU7MTY0bV8bWzM5bRtbMzg7NTsx
MjltLxtbMzltG1szODs1OzEyOW0gG1szOW0bWzM4OzU7OTNtIBtbMzltG1szODs1OzkzbS8bWzM5
bRtbMzg7NTs2M21fG1szOW0bWzM4OzU7NjNtLhtbMzltG1szODs1OzMzbV8bWzM5bRtbMzg7NTsz
M21fG1szOW0bWzM4OzU7MzltXxtbMzltG1szODs1OzM5bS8bWzM5bRtbMzg7NTs0NG1fG1szOW0b
WzM4OzU7NDRtXxtbMzltG1szODs1OzQ5bV8bWzM5bRtbMzg7NTs0OW1fG1szOW0bWzM4OzU7NDht
LxtbMzltG1szODs1OzQ4bSAbWzM5bRtbMzg7NTs4M20gG1szOW0bWzM4OzU7ODNtG1szOW0KG1sz
ODs1OzEyOW0gG1szOW0bWzM4OzU7OTNtIBtbMzltG1szODs1OzkzbSAbWzM5bRtbMzg7NTs2M20g
G1szOW0bWzM4OzU7NjNtIBtbMzltG1szODs1OzMzbSAbWzM5bRtbMzg7NTszM20gG1szOW0bWzM4
OzU7MzltIBtbMzltG1szODs1OzM5bSAbWzM5bRtbMzg7NTs0NG0gG1szOW0bWzM4OzU7NDRtIBtb
MzltG1szODs1OzQ5bSAbWzM5bRtbMzg7NTs0OW0gG1szOW0bWzM4OzU7NDhtIBtbMzltG1szODs1
OzQ4bSAbWzM5bRtbMzg7NTs4M20gG1szOW0bWzM4OzU7ODNtIBtbMzltG1szODs1OzExOW0gG1sz
OW0bWzM4OzU7MTE4bSAbWzM5bRtbMzg7NTsxNTRtG1szOW0K
EOF
)
  umask 077
  printf '%s\n' "$logo" >&2
  remotename=remote
  always=false
  command="proxy"
  proxyname=proxy
  [ -f ~/.rbs.conf ] && . ~/.rbs.conf
  while getopts 'hac:r:R:p:P:f:' opt;do
    case "$opt" in
      c) . "$OPTARG";;
      r) remote="$OPTARG";;
      R) remotename="$OPTARG";;
      p) proxy="$OPTARG";;
      P) proxyname="$OPTARG";;
      f) fifo_prox="$OPTARG";;
      a) always=true;;
      h|\?) usage;;
    esac
  done
  shift $((OPTIND-1))
  [ "$1" ] && {
    target="$1"
    shift
    cd ~/.ssh
    exec ssh -F rbs_proxy $target "$@"
  }
  [ "$remote" ] || { echo "Remote not specified" >&2; usage; }
  : ${UID:=$(id -u)}
  [[ $remote = *@* ]] && user="User ${remote%@*}" || user=""
  remote=${remote##*@}
  : ${fifo_prox:=$(mktemp -up.)}
  fifo_prox="${fifo_prox##*.}"
  proxy_cmd=$(cat - <<EOF
cd \${XDG_RUNTIME_DIR:-/tmp}
[ -p $fifo_prox ] || { echo "No proxy found" >&2; exit 1; }
printf "Waiting proxy..." >&2
s=\$(mktemp -up.)
s=\${s##*.}
rm -f \$s
echo \$1:\$s >$fifo_prox
trap 'sleep 2;[ -S \$s ] && nc --send-only -U \$s <<<"" && rm -f \$s;exit' INT TERM
while [ ! -S \$s ];do sleep 0.1;done
( ( sleep 0.5; rm -f \$s ) & exit 0 ) & wait
printf "ok\n" >&2
exec nc -U \$s
EOF
  )
  printf "ProxyCommand ssh %s 'bash <(base64 -d <<<%s) %%h'\n\n" "$remote" "$(base64 -w 0 <<<"$proxy_cmd")"
  remote_cmd=$(cat - <<EOF
echo "$command:${proxy:-localhost}[$proxyname] -> $fifo_prox -> \$USER@$remote[$remotename]" >&2
umask 077
cd \${XDG_RUNTIME_DIR:-/tmp}
cat - <<'EOZ' >~/.ssh/rbs_proxy
Host *
  ProxyCommand bash <(base64 -d <<<$(base64 -w0 <<<"$proxy_cmd")) %h
EOZ
rm -f $fifo_prox
mkfifo $fifo_prox
trap 'rm -f $fifo_prox' EXIT
(echo >$fifo_prox) & # init fifo to have tail output to get kernel signal on exit
tail -f $fifo_prox
wait
EOF
  )
  cat - >~/.ssh/rbs <<EOF
Host $remotename
  LogLevel ERROR
  Hostname $remote
  RequestTTY no
  RemoteCommand bash <(base64 -d <<<$(base64 -w0 <<<"$remote_cmd"))
  $user
EOF
}

[ "$_rbs_post" ] || {
  rbs_pre "$@"
  export remotename remote always proxy proxyname
  _rbs_post=1 exec bash <$0
}
umask 077
grep -q "^[[:space:]]*Include ~/.ssh/rbs" ~/.ssh/config 2>/dev/null && ssh_conf='' || ssh_conf='-F rbs'
cd ~/.ssh
ssh_config="$(cat rbs)"
#trap "rm -f $fifo ~/.ssh/.bashrc;> ~/.ssh/rbs" EXIT
export TMPDIR="${XDG_RUNTIME_DIR:-/tmp}"

serve() {
  cat - >~/.ssh/rbs <<<"$ssh_config"
  coproc PROD { exec ssh $remotename $ssh_conf; }
  sleep 0.5;>~/.ssh/rbs
  while read h;do
    [ ! "$h" ] && continue
    printf -v h '%q' "$h"
    host="${h%:*}"
    sock="${h##*:}"
    [[ "$host" =~ ^[0-9A-Za-z._-]+$ ]] || { echo "Invalid host name: $host" >&2; continue; }
    [[ "$sock" =~ ^[0-9A-Za-z]+$ ]] || { echo "Invalid sock name: $sock" >&2; continue; }
    printf '%s\n' "Connect to $host:$sock" >&2
    fifo="$(mktemp -u)"
    mkfifo $fifo
    cat - <<EOF >~/.ssh/rbs
Host $host.
  LogLevel ERROR
  Hostname $remote
  RequestTTY no
  RemoteCommand cd \${XDG_RUNTIME_DIR:-/tmp};umask 077;exec nc -lU $sock
  #RemoteCommand bash <(base64 -d <<<$(base64 -w0 <<<"cd \${XDG_RUNTIME_DIR:-/tmp};umask 077;exec nc -lU $sock")) # zombie ?
EOF
    [ "$proxy" ] && {
      cat - <<EOF >>~/.ssh/rbs
Host $proxyname
  LogLevel ERROR
  Hostname $proxy
  RequestTTY no
  RemoteCommand nc "$host" 22
EOF
    (ssh "$proxyname" $ssh_conf <$fifo | ssh "$host." $ssh_conf >$fifo) &
    } || (nc "$host" 22 <$fifo | ssh "$host." $ssh_conf >$fifo) &
    sleep 0.5
    rm -f $fifo
    > ~/.ssh/rbs
  done <&"${PROD[0]}"
  kill "$PROD_PID" 2>/dev/null
  wait
}

serve_always() {
  while true;do
    serve
    sleep 2 & wait
  done
}

$always && {
  serve_always
  exit
}

trap 'trap - INT TERM;kill 0' INT TERM
serve
