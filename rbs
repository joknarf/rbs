#!/bin/bash
# tty forwarder/relay over ssh
# serves an interactive shell/command on a remote host using ssh
# connnect to it from remote host
# example:
#   serve a shell on host to remote: rbs -r <remote> 
#   connect to host from remote: rbs
#
# Author: joknarf

usage() {
  printf '%s' 'usage: 
  server: rbs -r <remote> [-p <port>|-S <sock>] [-P <passfile|->] [-t ttyserver] [-T <ttysrvname>] [-R <remotename>] [-H <bind>] [-c config] [-C <command>] [-a] [-s]
  client: rbs [-p port]

  -r remote     : ip/host to serve shell
  -S sock       : unix socket file to listen/connect on remote (/tmp/rbs.<remotename>.sock)
  -p port       : port to listen on remote (4444)
  -P passfile   : file containing password or '-' to enter interactively
  -t ttyserver  : host to serve shell (localhost)
  -T ttysrvname : localhost ssh host (local)
  -R remotename : remote ssh host (remote)
  -H bind       : bind/connect address (localhost)
  -C command    : shell command to execute on local and serve (bash -l)
  -c config     : config file to load (~/.rbs.conf)
  -a            : always serve (relaunch on disconnect)
  -s            : use ssh instead of script for local shell
  '
  exit 0
}

rbs_pre() {
  logo=$(base64 -d <<'EOF'
G1szODs1OzE4NG0gG1szOW0bWzM4OzU7MjE0bSAbWzM5bRtbMzg7NTsyMTRtIBtbMzltG1szODs1
OzIwOG0gG1szOW0bWzM4OzU7MjA4bSAbWzM5bRtbMzg7NTsyMDNtIBtbMzltG1szODs1OzIwM20g
G1szOW0bWzM4OzU7MTk4bSAbWzM5bRtbMzg7NTsxOThtIBtbMzltG1szODs1OzE5OW1fG1szOW0b
WzM4OzU7MTk5bV8bWzM5bRtbMzg7NTsxNjRtIBtbMzltG1szODs1OzE2NG0gG1szOW0bWzM4OzU7
MTY0bSAbWzM5bRtbMzg7NTsxMjltIBtbMzltG1szODs1OzEyOW0gG1szOW0bWzM4OzU7OTNtIBtb
MzltG1szODs1OzkzbSAbWzM5bRtbMzg7NTs2M20gG1szOW0bWzM4OzU7NjNtG1szOW0KG1szODs1
OzIwOG0gG1szOW0bWzM4OzU7MjA4bSAbWzM5bRtbMzg7NTsyMDNtIBtbMzltG1szODs1OzIwM21f
G1szOW0bWzM4OzU7MTk4bV8bWzM5bRtbMzg7NTsxOThtXxtbMzltG1szODs1OzE5OW1fG1szOW0b
WzM4OzU7MTk5bV8bWzM5bRtbMzg7NTsxNjRtLxtbMzltG1szODs1OzE2NG0gG1szOW0bWzM4OzU7
MTY0bS8bWzM5bRtbMzg7NTsxMjltXxtbMzltG1szODs1OzEyOW0gG1szOW0bWzM4OzU7OTNtIBtb
MzltG1szODs1OzkzbV8bWzM5bRtbMzg7NTs2M21fG1szOW0bWzM4OzU7NjNtXxtbMzltG1szODs1
OzMzbV8bWzM5bRtbMzg7NTszM21fG1szOW0bWzM4OzU7MzltG1szOW0KG1szODs1OzIwM20gG1sz
OW0bWzM4OzU7MTk4bSAbWzM5bRtbMzg7NTsxOThtLxtbMzltG1szODs1OzE5OW0gG1szOW0bWzM4
OzU7MTk5bV8bWzM5bRtbMzg7NTsxNjRtXxtbMzltG1szODs1OzE2NG1fG1szOW0bWzM4OzU7MTY0
bS8bWzM5bRtbMzg7NTsxMjltIBtbMzltG1szODs1OzEyOW1fG1szOW0bWzM4OzU7OTNtXxtbMzlt
G1szODs1OzkzbSAbWzM5bRtbMzg7NTs2M21cG1szOW0bWzM4OzU7NjNtLxtbMzltG1szODs1OzMz
bSAbWzM5bRtbMzg7NTszM21fG1szOW0bWzM4OzU7MzltXxtbMzltG1szODs1OzM5bV8bWzM5bRtb
Mzg7NTs0NG0vG1szOW0bWzM4OzU7NDRtG1szOW0KG1szODs1OzE5OW0gG1szOW0bWzM4OzU7MTk5
bS8bWzM5bRtbMzg7NTsxNjRtIBtbMzltG1szODs1OzE2NG0vG1szOW0bWzM4OzU7MTY0bSAbWzM5
bRtbMzg7NTsxMjltIBtbMzltG1szODs1OzEyOW0vG1szOW0bWzM4OzU7OTNtIBtbMzltG1szODs1
OzkzbS8bWzM5bRtbMzg7NTs2M21fG1szOW0bWzM4OzU7NjNtLxtbMzltG1szODs1OzMzbSAbWzM5
bRtbMzg7NTszM20oG1szOW0bWzM4OzU7MzltXxtbMzltG1szODs1OzM5bV8bWzM5bRtbMzg7NTs0
NG0gG1szOW0bWzM4OzU7NDRtIBtbMzltG1szODs1OzQ5bSkbWzM5bRtbMzg7NTs0OW0gG1szOW0b
WzM4OzU7NDhtG1szOW0KG1szODs1OzE2NG0vG1szOW0bWzM4OzU7MTY0bV8bWzM5bRtbMzg7NTsx
MjltLxtbMzltG1szODs1OzEyOW0gG1szOW0bWzM4OzU7OTNtIBtbMzltG1szODs1OzkzbS8bWzM5
bRtbMzg7NTs2M21fG1szOW0bWzM4OzU7NjNtLhtbMzltG1szODs1OzMzbV8bWzM5bRtbMzg7NTsz
M21fG1szOW0bWzM4OzU7MzltXxtbMzltG1szODs1OzM5bS8bWzM5bRtbMzg7NTs0NG1fG1szOW0b
WzM4OzU7NDRtXxtbMzltG1szODs1OzQ5bV8bWzM5bRtbMzg7NTs0OW1fG1szOW0bWzM4OzU7NDht
LxtbMzltG1szODs1OzQ4bSAbWzM5bRtbMzg7NTs4M20gG1szOW0bWzM4OzU7ODNtG1szOW0KG1sz
ODs1OzEyOW0gG1szOW0bWzM4OzU7OTNtIBtbMzltG1szODs1OzkzbSAbWzM5bRtbMzg7NTs2M20g
G1szOW0bWzM4OzU7NjNtIBtbMzltG1szODs1OzMzbSAbWzM5bRtbMzg7NTszM20gG1szOW0bWzM4
OzU7MzltIBtbMzltG1szODs1OzM5bSAbWzM5bRtbMzg7NTs0NG0gG1szOW0bWzM4OzU7NDRtIBtb
MzltG1szODs1OzQ5bSAbWzM5bRtbMzg7NTs0OW0gG1szOW0bWzM4OzU7NDhtIBtbMzltG1szODs1
OzQ4bSAbWzM5bRtbMzg7NTs4M20gG1szOW0bWzM4OzU7ODNtIBtbMzltG1szODs1OzExOW0gG1sz
OW0bWzM4OzU7MTE4bSAbWzM5bRtbMzg7NTsxNTRtG1szOW0K
EOF
)
  printf '%s\n' "$logo"
  port=""
  password="$RB_PASS"
  ttyserver=localhost
  ttysrvname=local
  remotename=remote
  always=false
  use_ssh=false
  command="bash -l"
  [ -f ~/.rbs.conf ] && . ~/.rbs.conf
  while getopts 'hsac:r:R:p:P:S:C:t:T:H:' opt;do
    case "$opt" in
      c) . "$OPTARG";;
      C) command="$OPTARG";;
      r) remote="$OPTARG";;
      t) ttyserver="$OPTARG";;
      p) port="$OPTARG";;
      P) passfile="$OPTARG";;
      T) ttysrvname="$OPTARG";;
      R) remotename="$OPTARG";;
      S) sock="$OPTARG";;
      a) always=true;;
      s) use_ssh=true;;
      H) bind="$OPTARG";;
      h|\?) usage;;
    esac
  done
  [ "$bind" ] && port="${port:-4444}"
  bind="${bind:-localhost}"
  sockfile=${sock:-"/tmp/.rbs.$USER.$ttysrvname.sock"}
  sock=${sock:-"/tmp/.rbs.\$USER.$ttysrvname.sock"}
  [ ! "$remote" ] && [ ! -e "$sockfile" ] && port="${port:-4444}"
  [ "$ttyserver" != localhost ] && use_ssh=true
  [ "$port" ] && {
    connect_cmd="socat STDIO,raw,echo=0 TCP:$bind:$port"
    listen_cmd="socat - TCP-LISTEN:$port,bind=$bind,reuseaddr"
    clean_cmd=""
  } || {
    connect_cmd="socat STDIO,raw,echo=0 UNIX-CONNECT:$sockfile"
    listen_cmd="socat - UNIX-LISTEN:$sock,mode=600"
    clean_cmd="rm -f $sock;"
  }
  [ "$remote" ] || {
    printf '%s\n' "Connect: ${connect_cmd##* }"
    $connect_cmd
    exit
  }
  [ "$passfile" ] && {
    [ "$passfile" = - ] && { read -s -p "Password: " password;echo; } || password=$(cat "$passfile")
  }

  rcommand=""
  [ "$password" ] && {
    token=$(openssl rand -base64 32 | tr '+/' '-_' | tr -d '=')
    gpg64=$(gpg -c --batch --cipher-algo AES256 --passphrase-file <(printf %s $password) <<<"$token" |base64 -w0)
    rcommand=$(cat - <<EOF
read -s -p "Password: " p;base64 -d <<<$gpg64 | gpg -d --batch --passphrase-file <(printf %s "\$p") >/dev/null 2>&1 || exit 1
EOF
    )
  } || rcommand='read -s -n 1 -p "Press any key to continue..."'
  rcommand="$rcommand; echo; cd; type resize >/dev/null 2>&1 && . <(resize 2>/dev/null); RBS=true exec $command"
  echo "$rcommand" >~/.ssh/.bashrc
  cat - >~/.ssh/rbs <<EOF
Host $remotename
  Hostname $remote
  RequestTTY no
  RemoteCommand $clean_cmd pkill -U \$UID -f "^$listen_cmd"; sleep 1;exec $listen_cmd

Host $ttysrvname
  Hostname $ttyserver
  RequestTTY force
  RemoteCommand exec bash --rcfile <(printf %%s '${rcommand//%/%%}')
EOF

}
[ "$_rbs_post" ] || {
  rbs_pre "$@"
  export remotename ttysrvname always use_ssh
  port="${port:-$sock}"
  echo "$ttyserver($ttysrvname):$command -> $remote($remotename):$port"
  _rbs_post=1 exec bash <$0
}
fifo="$(mktemp -u -t .XXXXXXXXXXX)"
(umask 0077;mkfifo $fifo) || exit 1
trap "rm -f $fifo ~/.ssh/.bashrc;> ~/.ssh/rbs" EXIT
cd ~/.ssh
grep -q "^[[:space:]]*Include ~/.ssh/rbs" ~/.ssh/config && ssh_conf='' || ssh_conf='-F rbs'

serve() {
  #  script -q -f -c "exec bash --rcfile .bashrc" /dev/null <$fifo |ssh $remotename $ssh_conf >$fifo
  #  ssh $ttysrvname $ssh_conf <$fifo | ssh $remotename $ssh_conf >$fifo
  # use coproc to kill $ttyserver shell/ssh on remote disconnect
  $use_ssh && coproc PROD { exec ssh $ttysrvname $ssh_conf <$fifo; } || \
              coproc PROD { exec script -qfc "exec bash --rcfile .bashrc" /dev/null <$fifo; }
  ssh $remotename $ssh_conf >$fifo <&"${PROD[0]}"
  kill "$PROD_PID" 2>/dev/null
  wait
}

serve_always() {
  while true;do
    serve
    sleep 5 & wait
  done
}

$always && {
  trap "trap - INT TERM;kill 0" INT TERM
  serve_always
  exit
}
serve
